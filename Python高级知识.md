> “A quitter never wins and a winner never quits” — Napoleon Hill

## 3.1 垃圾回收

- [深入理解Python内存管理与垃圾回收，再也不怕问了（一）](https://yuzhoustayhungry.github.io/post/python内存管理与垃圾回收/)

- [也来说说Python的垃圾回收机制？](https://yuzhoustayhungry.github.io/post/python%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/)



垃圾回收是在正在运行的程序中查找将来无法访问的数据对象，并回收那些对象所使用的资源（尤其是内存）的过程。 自动垃圾收集的语言--Java，C#，Python和大多数脚本语言。 C是没有垃圾回收的语言-程序员需要了解何时应该分配和回收内存。

- 大多数垃圾回收语言都使用**引用计数**（reference counting,跟踪对象的引用数量）或可达性分析（tracing,从“根”对象开始，查找可被一系列引用访问的对象，剩下没有被引用的对象将被视作“垃圾”被回收）。

- Python使用引用计数，好处是当引用计数变为0时，它可以立即回收对象。这样做的代价是需要为每个对象存储一个附加的整数值。可达性分析（Java中使用）的好处是可以在独立的线程中执行，从而提高性能。缺点是，当垃圾收集器运行时，程序会暂停所有的线程。

- 引用计数的缺点是无法解决“循环引用”，例如：对象A和对象B互相引用，`A.x = B`和`B.y = A`，这样会引用计数不会变到1以下，即使没有其它的对象引用A和B，在这种情况下，垃圾收集器会定期查找并删除它们。
- 垃圾收集器使用启发式方法提高速度。 例如，根据经验，最近创建的对象更有可能死掉。 因此，在创建对象时，将它们分配给不同的代，然后首先检查年轻的代。

## 3.2 深拷贝和浅拷贝

> 参看之前的文章：[学习Python一年，这次终于弄懂了浅拷贝和深拷贝](https://yuzhoustayhungry.github.io/post/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/)

问：浅拷贝和深拷贝的区别？

答：

- `copy.copy(x)`和`copy.deepcopy(x)`，浅拷贝将构造一个新的复合对象，然后（在可能的范围内）将对原始对象中找到的对象的引用插入其中。 深拷贝将构造一个新的复合对象，然后递归地将原始对象中的对象的副本插入其中。

- 浅拷贝和深拷贝之间的区别仅与复合对象有关，复合对象即包含其他对象（例如列表或类实例）的对象。
- 如果已知客户端不会改变对象，可以少用copy。类似地，如果对象本身是不可变的，例如tuple，则无需拷贝它。

## 3.3 迭代器和生成器

问：迭代器和生成器的区别？

**迭代器：** 一个实现了`__iter__()`和`__next__()`方法的对象。第一个方法返回迭代器对象本身，并在for和in语句中使用。第一个方法在迭代中返回下一个值，如果没有更多的元素，将引发`StopIteration`异常。

**生成器：** 创建迭代器的简便方法，使用关键字`yield`。生成器使用函数调用堆栈隐式存储迭代器的状态-与编写与作为显式类相同的迭代器相比，可以简化迭代器的编写。 它还有助于提高可读性。

每个生成器都是一个迭代器，但反过来就不正确。 特别是，迭代器可以是完全成熟的类，因此可以提供其他功能。 例如，在上面的迭代器类中添加一个方法来更改迭代限制很容易，这对于生成器是不可能的。

### 3.4 装饰器 @decorator



### 3.5 List vs. tuple



### 3.6 *args 和 *kwargs



## 3.7 错误处理、异常机制



## 3.8 函数式编程、闭包



```python
increment_by_i = [lambda x: x + i for i in range(10)]
print(increment_by_i[3](4))
```



该程序将打印13（= 9 + 4），而不是预期的7（= 3 + 4）。 这是因为在循环中创建的函数具有相同的作用域。 它们使用相同的变量名称，因此，它们都引用相同的变量*i*，在循环末尾为10，因此为13（= 9 + 4）。

有很多方法可以得到所需的行为。 合理的方法是从函数返回lambda，从而避免命名冲突。

## 3.9 函数参数