> “A quitter never wins and a winner never quits” — Napoleon Hill

## 3.1 垃圾回收

[深入理解Python内存管理与垃圾回收，再也不怕问了（一）](https://yuzhoustayhungry.github.io/post/python内存管理与垃圾回收/)

[也来说说Python的垃圾回收机制？](https://yuzhoustayhungry.github.io/post/python%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/)



垃圾回收是在正在运行的程序中查找将来无法访问的数据对象，并回收那些对象所使用的资源（尤其是内存）的过程。 自动垃圾收集的语言--Java，C#，Python和大多数脚本语言。 C是没有垃圾回收的语言-程序员需要了解何时应该分配和回收内存。

- 大多数垃圾回收语言都使用**引用计数**（reference counting,跟踪对象的引用数量）或可达性分析（tracing,从“根”对象开始，查找可被一系列引用访问的对象，剩下没有被引用的对象将被视作“垃圾”被回收）。

- Python使用引用计数，好处是当引用计数变为0时，它可以立即回收对象。这样做的代价是需要为每个对象存储一个附加的整数值。可达性分析（Java中使用）的好处是可以在独立的线程中执行，从而提高性能。缺点是，当垃圾收集器运行时，程序会暂停所有的线程。

- 引用计数的缺点是无法解决“循环引用”，例如：对象A和对象B互相引用，`A.x = B`和`B.y = A`，这样会引用计数不会变到1以下，即使没有其它的对象引用A和B，在这种情况下，垃圾收集器会定期查找并删除它们。
- 垃圾收集器使用启发式方法提高速度。 例如，根据经验，最近创建的对象更有可能死掉。 因此，在创建对象时，将它们分配给不同的代，然后首先检查年轻的代。

## 3.2 深拷贝和浅拷贝

[学习Python一年，这次终于弄懂了浅拷贝和深拷贝](https://yuzhoustayhungry.github.io/post/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/)

## 3.3 迭代器和生成器



### 3.4 装饰器 @decorator



### 3.5 List vs. tuple



### 3.6 *args 和 *kwargs



## 3.7 错误处理、异常机制



## 3.8 函数式编程、闭包



## 3.9 函数参数